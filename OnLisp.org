#+Title: On Lisp

* Table of contents                                                   :TOC_3:
- [[#2-functions][2. Functions]]
  - [[#22-defining-functions][2.2 Defining Functions]]
    - [[#symbol-equality][Symbol Equality]]
    - [[#lambda][Lambda]]
    - [[#function-application][Function application]]
    - [[#lambda-application][Lambda application]]
    - [[#lisp-treats-variable-and-function-definition-separately][Lisp treats variable and function definition separately]]
    - [[#function-definition-in-lisp][Function definition in Lisp]]
  - [[#23-functional-arguments][2.3 Functional Arguments]]
    - [[#argument-application][Argument application]]
    - [[#these-do-not-work][These do not work]]
    - [[#non-pair-argument-application][Non pair argument application]]
    - [[#higher-order-functions][Higher order functions]]
    - [[#our-remove-if][our-remove-if]]
  - [[#24-functions-as-properties][2.4 Functions as Properties]]

* 2. Functions
** 2.2 Defining Functions

#+BEGIN_SRC lisp :exports both :results replace drawer
  (defun d (x) (* x 2))
#+END_SRC

#+RESULTS:
:RESULTS:
D
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
  (d 1)
#+END_SRC

#+RESULTS:
:RESULTS:
2
:END:

Using the actual "double" symbol name does not work since SBCL complains that it's a redefinition.

#+BEGIN_SRC lisp :exports both :results replace drawer
#'d
#+END_SRC

#+RESULTS:
:RESULTS:
#<FUNCTION D>
:END:

*** Symbol Equality
#+BEGIN_SRC lisp :exports both :results replace drawer
  (eq #'d (car (list #'d)))
#+END_SRC

#+RESULTS:
:RESULTS:
T
:END:

*** Lambda
**** Lambda evaluation
#+BEGIN_SRC lisp :exports both :results drawer
  (lambda (x) (* x x))
#+END_SRC

#+RESULTS:
:RESULTS:
#<FUNCTION (LAMBDA (X)) {226D0D6B}>
:END:

**** Lambda reference
#+BEGIN_SRC lisp :exports both :results drawer
  #'(lambda (x) (* x x))
#+END_SRC

#+RESULTS:
:RESULTS:
#<FUNCTION (LAMBDA (X)) {226D0ECB}>
:END:

The result is not different if the lambda is prepended by a sharp-quote.

*** Function application
#+BEGIN_SRC lisp :exports both :results drawer
  (d 3)
#+END_SRC

#+RESULTS:
:RESULTS:
6
:END:

*** Lambda application
#+BEGIN_SRC lisp :exports both :results replace drawer
  ((lambda (x) (* x x)) 3)
#+END_SRC

#+RESULTS:
:RESULTS:
9
:END:

*** Lisp treats variable and function definition separately
#+BEGIN_SRC lisp :exports both :results replace drawer
  (setq d 2)
#+END_SRC

#+RESULTS:
:RESULTS:
2
:END:

I'm not sure I prefer this behavior compared to Scheme. I think this introduces confusion in the language, since there are more rules. There's a potential for this to break function composition, as in ~(f g)~.

**** Symbol value
#+BEGIN_SRC lisp :exports both :results replace drawer
  (symbol-value 'd)
#+END_SRC

#+RESULTS:
:RESULTS:
2
:END:

**** Symbol function
#+BEGIN_SRC lisp :exports both :results replace drawer
  (symbol-function 'd)
#+END_SRC

#+RESULTS:
:RESULTS:
#<FUNCTION D>
:END:

**** Functions can be assigned to variables
#+BEGIN_SRC lisp :exports both :results replace drawer
  (setq x #'append)
#+END_SRC

#+RESULTS:
:RESULTS:
#<FUNCTION APPEND>
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
x
#+END_SRC

#+RESULTS:
:RESULTS:
#<FUNCTION APPEND>
:END:

*Check for equality*
#+BEGIN_SRC lisp :exports both :results replace drawer
  (eq (symbol-value 'x) (symbol-function 'append))
#+END_SRC

#+RESULTS:
:RESULTS:
T
:END:

*** Function definition in Lisp
**** The usual way
#+BEGIN_SRC lisp :exports both :results replace drawer
  (defun d (x) (* x 2))
#+END_SRC

#+RESULTS:
:RESULTS:
D
:END:

**** Under the hood
#+BEGIN_SRC lisp :exports both :results replace drawer
  (setf (symbol-function 'd)
        #'(lambda (x) (* x 2)))
#+END_SRC

#+RESULTS:
:RESULTS:
#<FUNCTION (LAMBDA (X)) {226D1E0B}>
:END:
** 2.3 Functional Arguments
*** Argument application
#+BEGIN_SRC lisp :exports both :results replace drawer
  (+ 1 2)
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
  (apply #'+ '(1 2))
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
  (apply (symbol-function '+) '(1 2))
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
  (apply #'(lambda (x y) (+ x y)) '(1 2))
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
  (apply #'+ 1 '(2))
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

*** These do not work
#+BEGIN_SRC lisp :exports both :results replace drawer
  (apply #'+ '(1) 2)
  (apply #'+ '(1) (2))
  (apply #'+ 1 2)
#+END_SRC

*** Non pair argument application
#+BEGIN_SRC lisp :exports both :results replace drawer
  (funcall #'+ 1 2)
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

*** Higher order functions
#+BEGIN_SRC lisp :exports both :results replace drawer
  (mapcar
   #'(lambda (x) (+ x 10))
   '(1 2 3))
#+END_SRC

#+RESULTS:
:RESULTS:
(11 12 13)
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
  (sort '(9 5 7 4 3) #'<)
#+END_SRC

#+RESULTS:
:RESULTS:
(3 4 5 7 9)
:END:

#+BEGIN_SRC lisp :exports both :results replace drawer
  (remove-if #'evenp '(1 2 3 4 5 6 7 8))
#+END_SRC

#+RESULTS:
:RESULTS:
(1 3 5 7)
:END:

*** our-remove-if
#+BEGIN_SRC lisp :exports both :results replace drawer
  (defun our-remove-if (fn lst)
    (if (null lst)
        nil
        (if (funcall fn (car lst))
            (our-remove-if fn (cdr lst))
            (cons (car lst) (our-remove-if fn (cdr lst))))))

  (our-remove-if #'oddp '(1 2 3 4 5 6 7))
#+END_SRC

#+RESULTS:
:RESULTS:
(2 4 6)
:END:
** 2.4 Functions as Properties
#+BEGIN_SRC lisp :exports both :results replace drawer
  (setf (get 'dog 'behavior)
        #'(lambda ()
            'wag-tail))

  (setf (get 'cat 'behavior)
        #'(lambda ()
            'rub-legs))

  (funcall (get 'cat 'behavior))
#+END_SRC

#+RESULTS:
:RESULTS:
RUB-LEGS
:END:

This is different from Scheme.
In Scheme, a function application is straightforward.
#+BEGIN_SRC scheme :exports both :results replace drawer
  ((lambda (x) (* x x)) 3)
#+END_SRC

#+RESULTS:
:RESULTS:
9
:END:

Lisp requires funcall
#+BEGIN_SRC lisp :exports both :results replace drawer
  (funcall #'(lambda (x) (* x x)) 3)
#+END_SRC

#+RESULTS:
:RESULTS:
9
:END:
